// Bruteforce Approach

class Solution {
    static int findLastOccurence(String text, String target) {
        int lastIndex = text.lastIndexOf(target);
        return (lastIndex != -1) ? (lastIndex + 1) : -1; // 1-based index
    }
}


// Better Approach

class Solution {
    static int findLastOccurence(String text, String target) {
        int lastIndex = -1;
        for (int i = 0; i <= (text.length() - target.length()); i++) {
            int j;
            for (j = 0; j < target.length(); j++) {
                if (text.charAt(i + j) != target.charAt(j)) {
                    break;
                }
            }

            // Full match
            if (j == target.length()) {
                lastIndex = i + 1; // 1-based index
            }
        }

        return lastIndex;
    }
}


//Optimal Approach

class Solution {
    static int findLastOccurence(String text, String target) {
        // Start scanning from the end of the main string
        for (int i = text.length() - 1; i >= target.length() - 1; i--) {
            int j;
            int k = i;
            
            // Compare characters of 'target' with current window in 'text' (from end to start)
            for (j = target.length() - 1; j >= 0; j--, k--) {
                if (text.charAt(k) != target.charAt(j)) {
                    break; // Break early if mismatch found
                }
            }

            // If j < 0, all characters matched â€” substring found
            if (j < 0) {
                // Convert to 1-based index
                return k + 2;
            }
        }

        // Substring not found
        return -1;
    }
}
