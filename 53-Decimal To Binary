/*
Let's take the example of converting the decimal number 25 to binary:

Start with the decimal number (25).

Divide the decimal number by 2:
Quotient: 25 / 2 = 12
Remainder: 1

Continue dividing the quotient by 2:
Quotient: 12 / 2 = 6
Remainder: 0

Continue dividing the quotient by 2:
Quotient: 6 / 2 = 3
Remainder: 0

Continue dividing the quotient by 2:
Quotient: 3 / 2 = 1
Remainder: 1

Once more:
Quotient: 1 / 2 = 0
Remainder: 1

Reading the remainders from bottom to top, we get the binary representation: 11001.
*/

//Naive Approach (Will only work for Positive Integers ,fail for Negative Integers and 0)

public class Solution {
    public static void toBinary(int decimal) {
        if (decimal == 0) {
            System.out.print("0");
            return;
        }

        StringBuilder binary = new StringBuilder();

        while (decimal != 0) {
            int remainder = decimal % 2;
            binary.append(remainder);
            decimal = decimal / 2;
        }

        System.out.print(binary.reverse().toString());
    }
}


//Optimal Approach (Will work for Positive Integers ,Negative Integers and 0)

public class Solution {
    public static void toBinary(int decimal) {
        // Direct return for zero (special case)
        if (decimal == 0) {
            System.out.println("0");
            return;
        }

        boolean isNegative = false;

        // Mark sign and work with absolute value
        if (decimal < 0) {
            isNegative = true;
            decimal = Math.abs(decimal);
        }

        // If negative → compute two’s complement on padded binary
        // If positive → just normal binary
        String binary = isNegative ? twosComplement(toBinary(decimal, true)) : toBinary(decimal, false).toString();

        System.out.print(binary);
    }

    private static StringBuilder toBinary(int decimal, boolean isNegative) {
        StringBuilder binary = new StringBuilder();

        while (decimal != 0) {
            int remainder = decimal % 2;
            binary.append(remainder);
            decimal /= 2;
        }

        // For negative numbers, pad with zeros until length becomes 32.
        while (isNegative && binary.length() < 32) {
            binary.append('0');
        }

        // Final binary must be MSB → LSB, so reverse it
        return binary.reverse();
    }

    // flip all bits → add 1.
    private static String twosComplement(StringBuilder binary) {
        int carry = 1; // Start with +1 to complete two’s complement

        // Traverse from LSB to MSB
        for (int i = binary.length() - 1; i >= 0; i--) {
            int bit = binary.charAt(i) - '0';

            // Flip the bit manually (0→1, 1→0)
            int flipped = (bit == 0) ? 1 : 0;

            int sum = flipped + carry;
            carry = sum / 2;

            // Set resulting bit ('0' or '1')
            binary.setCharAt(i, (char) ((sum % 2) + '0'));
        }

        return binary.toString();
    }
}


//Aliter : inbuilt Method (Will work for Positive Integers ,Negative Integers and 0)

public class Solution {
    public static void toBinary(int decimalNumber) {
        String binaryValue = Integer.toBinaryString(decimalNumber);
        System.out.print(binaryValue);
    }
}
