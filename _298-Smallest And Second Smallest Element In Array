//Without Recursion

class Compute {
   public long[] minAnd2ndMin(long arr[], long n){
       long[]res=new long[2];
       
       Arrays.fill(res,Long.MAX_VALUE);
	      
       for(int i=0;i<n;i++){
	  if(arr[i]<res[0]){
	     res[1]=res[0];
	     res[0]=arr[i];
	  }
          else if((arr[i]> res[0]) && (arr[i]<res[1])){
            res[1]=arr[i];
          }
       }
        
       if(res[1]==Long.MAX_VALUE){
         Arrays.fill(res,-1);
       }
             
       return res;    
    }
}


//Using Recursion

class Compute {
    public long[] minAnd2ndMin(long arr[], long n){
       return minAnd2ndMin(arr,n,0,Long.MAX_VALUE,Long.MAX_VALUE);    
    }
    
    public long[] minAnd2ndMin(long arr[],long n,int index,long min,long secMin){
      if(index==n){
        if(secMin==Long.MAX_VALUE){
          return new long[]{-1,-1};
        }
        return new long[]{min,secMin};
      }
      
      if(arr[index]<min){
	secMin=min;
	min=arr[index];
      }else if((arr[index]> min) && (arr[index]<secMin)){
        secMin=arr[index];
      }
      
    return minAnd2ndMin(arr,n,index+1,min,secMin);
   }
}

//Aliter

class Compute {
    public long[] minAnd2ndMin(long arr[], long n){
       return minAnd2ndMin(arr,Long.MAX_VALUE,Long.MAX_VALUE);    
    }
    
    public long[] minAnd2ndMin(long arr[],long min,long secMin){
      if(arr.length==0){
         if(secMin==Long.MAX_VALUE){
            return new long[]{-1,-1};
         } 
        return new long[]{min,secMin};
      }
      
      if(arr[0]<min){
	secMin=min;
	min=arr[0];
      }else if((arr[0]> min) && (arr[0]<secMin)){
        secMin=arr[0];
      }
      
      return minAnd2ndMin(Arrays.copyOfRange(arr,1,arr.length),min,secMin);
    }
}
