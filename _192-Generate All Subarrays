/* Subarrays :

1 : A subarray is contigious part of an array.
2 : Order of elements in the subarray should be same as in the array
3 : For an array of size 'n' there are (n*(n+1))/2 non-empty subarrays + 1 Empty subarray. 

*/

//Iterative Approach

class Solution {
    public List<List<Integer>> getSubArrays(int[] arr) {
        List<List<Integer>> subarrays = new ArrayList<>();
        List<Integer> currentSubarray = new ArrayList<>();

        for (int start = 0; start < arr.length; start++) {
            currentSubarray.clear();
            for (int end = start; end < arr.length; end++) {
                currentSubarray.add(arr[end]);
                subarrays.add(new ArrayList<>(currentSubarray));
            }
        }

        return subarrays;
    }
}


// Recurssive Approach

class Solution {
    private List<List<Integer>> subarrays;

    public List<List<Integer>> getSubArrays(int[] arr) {
        subarrays = new ArrayList<>();
        generateSubarrays(arr, 0, 0, new ArrayList<>());
        return subarrays;
    }

    private void generateSubarrays(int[] arr, int startIndex, int endIndex, List<Integer> currentSubarray) {
        // If startIndex reaches end of array, stop recursion
        if (startIndex == arr.length) {
            return;
        }

        // If endIndex runs out, move startIndex forward
        if (endIndex == arr.length) {
            currentSubarray.clear();
            generateSubarrays(arr, startIndex + 1, startIndex + 1, currentSubarray);
            return;
        }

        // Add current element and record the subarray
        currentSubarray.add(arr[endIndex]);
        subarrays.add(new ArrayList<>(currentSubarray));

        // Continue extending current subarray
        generateSubarrays(arr, startIndex, endIndex + 1, currentSubarray);
    }
}
