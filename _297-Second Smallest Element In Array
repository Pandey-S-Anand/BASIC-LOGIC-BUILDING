//Without Recursion

//Bruteforce Approach

class Solution {
    int print2Smallest(int arr[], int n) {
      int min=Integer.MAX_VALUE;
      for(int i=0;i<n;i++){
        if(arr[i]<min){
           min=arr[i];
        }
      }
      
      int secMin=Integer.MAX_VALUE;
      for(int i=0;i<n;i++){
         if(arr[i]<secMin && arr[i]>min){
            secMin=arr[i];
         }
      }
      
      return secMin;
    }
}

//Optimal Approach

class Solution {
    int print2Smallest(int arr[], int n) {
       int min=Integer.MAX_VALUE,secMin=Integer.MAX_VALUE;
       
       for(int i=0;i<n;i++){
           if(arr[i]<min){
              secMin=min;
              min=arr[i];
           }else if(arr[i]>min && arr[i]<secMin){
              secMin=arr[i];
           }
       }
       
       return secMin;
    }
}



//Using Recursion


class Solution{
    public int print2Smallest(int[] arr, int n) {
        return print2SmallestHelper(arr, n, 0,Integer.MAX_VALUE, Integer.MAX_VALUE);
    }

    private int print2SmallestHelper(int[] arr, int n, int index, int min, int secMin) {
        if (index == n) {
            return secMin;
        }

        if (arr[index] < min) {
            secMin = min;
            min = arr[index];
        } else if (arr[index] > min && arr[index] < secMin) {
            secMin = arr[index];
        }

        return print2SmallestHelper(arr, n, index + 1, min, secMin);
    }
}


// Optimal Implementation

class Solution {
    int print2Smallest(int[] arr, int n) {
        return print2SmallestHelper(arr,Integer.MAX_VALUE, Integer.MAX_VALUE);
    }

    private int print2SmallestHelper(int[] arr,int min, int secMin) {
        if (arr.length==0) {
            return secMin;
        }

        if (arr[0] < min) {
            secMin = min;
            min = arr[0];
        } else if (arr[0] > min && arr[0] < secMin) {
            secMin = arr[0];
        }

        return print2SmallestHelper(Arrays.copyOfRange(arr,1,arr.length),min, secMin);
    }
}
