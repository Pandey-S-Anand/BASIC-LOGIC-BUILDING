//Without Recursion

//Bruteforce Approach

class Solution {
    int print2largest(int arr[], int n) {
      int max=-1;
      for(int i=0;i<n;i++){
        if(arr[i]>max){
           max=arr[i];
        }
      }
      
      int secMax=-1;
      for(int i=0;i<n;i++){
         if(arr[i]>secMax && arr[i]<max){
            secMax=arr[i];
         }
      }
      
      return secMax;
    }
}

//Optimal Approach

class Solution {
    int print2largest(int arr[], int n) {
       int max=-1,secMax=-1;
       
       for(int i=0;i<n;i++){
           if(arr[i]>max){
              secMax=max;
              max=arr[i];
           }else if(arr[i]<max && arr[i]>secMax){
              secMax=arr[i];
           }
       }
       
       return secMax;
    }
}



//Using Recursion


class Solution{
    public int print2largest(int[] arr, int n) {
        return print2largestHelper(arr, n, 0, -1, -1);
    }

    private int print2largestHelper(int[] arr, int n, int index, int max, int secMax) {
        if (index == n) {
            return secMax;
        }

        if (arr[index] > max) {
            secMax = max;
            max = arr[index];
        } else if (arr[index] < max && arr[index] > secMax) {
            secMax = arr[index];
        }

        return print2largestHelper(arr, n, index + 1, max, secMax);
    }
}


// Optimal Implementation

class Solution {
    int print2largest(int[] arr, int n) {
        return print2largestHelper(arr,-1, -1);
    }

    private int print2largestHelper(int[] arr,int max, int secMax) {
        if (arr.length==0) {
            return secMax;
        }

        if (arr[0] > max) {
            secMax = max;
            max = arr[0];
        } else if (arr[0] < max && arr[0] > secMax) {
            secMax = arr[0];
        }

        return print2largestHelper(Arrays.copyOfRange(arr,1,arr.length),max, secMax);
    }
}
